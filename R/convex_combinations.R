#' Identification functions of convex combination of mode, mean, and median
#'
#' @param Y observation
#' @param X foreast
#' @param bw bandwidth. Numeric or function. (standard selects autamtically with rule of thumb)
#'
#' @return
#' @export
id_convex <- function(X, Y, theta=c(1/3,1/3), bw=bw_rule, vcov= iid, id_mode=id_modegaussian) {

  if(sum( theta<0)>0 | sum(theta > 1)>0)
    stop("Parameter theta invalid")

  if(sum(is.na(c(Y,X))>0))
    warning("NA values in data for id_mode function")

  if(is.function(bw))
    bw <- bw(X,Y)

  if(sum(is.na(bw))>0)
    stop("bandwith selection failed: NA")

  if(!is.numeric(bw))
    stop("bandwith not a number")


  #safe id values
  ids1 <- id_median(X,Y)
  ids2 <- id_mode(X,Y,bw)
  ids3 <- id_mean(X,Y)

  id <- as.numeric(theta[1]) * ids1/ as.numeric(sqrt(vcov(ids1)$cov))+
        as.numeric(theta[2]) * ids2/ as.numeric(sqrt(vcov(ids2)$cov)) +
        as.numeric(1-theta[1]-theta[2])*ids3/ as.numeric(sqrt(vcov(ids3)$cov))

  return(id)
}

#' Test convex combinations of mean, median and mode
#'
#' Inverts the J-test statistic of the convex combination of mean, median, and mode identification function.
#' The parts are normalized by a covariance estimator as denoted in vcov_inside. The weighting matrix for the different moments generated by the instrument vector is denoted by vcov.
#' The standard choice is iid, where the covariance is estimated by its simple sample analogon as proposed in the main paper.
#'
#' @param data data input (should contain X and Y)
#' @param x alternative input of X directly
#' @param y alternative input of Y directly
#' @param instruments character describing instruemnts or matrix
#' @param bw bw selection for mode
#' @param vcov covariance estimation for weigting matrix (as function)
#' @param number_values number of values for grid on parameter space
#' @param ... other paramters (use other_data for extracting different instruments)
#' @param id_mode identification function of mode
#' @param vcov_inside covariance estimator in the id_convex function (if NULL mirrors normal covariance estimator in vcov)
#' @param set_theta set of parameter values to be tested for. If NULL (standard) creates a set of equi-spaced values with a maximum of number_values in each dimension
#'
#' @return
#' @export
test_convex <- function(data=NULL,
                        x=NULL,
                        y=NULL,
                        instruments = c("1","X"),
                        id_mode = id_modegaussian,
                        bw = "bw_rule",
                        vcov=iid,
                        vcov_inside = iid,
                        number_values = 10,
                        set_theta = NULL,
                        ...
                        )
{

  ### transform inputs
  if(all(sapply(instruments,length)==1))
    instruments <- list(instruments)

  if(is.null(data) & (is.null(x)|is.null(y)))
     stop("data input missing")

  if(!is.null(data) & (!is.null(x) & !is.null(y)))
    warning("double input data")


  # draw X and Y from data
  if(!is.null(data))
  {
    if(is.character(x))
      x <- extract_col(data,x)
    else {
      #find forecast
      x <- extract_col(data, c("X","x","forecast","fc",
                               "mean_prediction","median_prediction",
                               "prediction","expectation","Survey"))
    }

    if(is.character(y))
      y <- extract_col(data,y)
    else {
      #find observations
      y <- extract_col(data, c("Y","y","observation","realization","cpi","income","Actual"))
    }
  }


  ### prepare
  n <- length(y)

  if(is.null(set_theta))
  {
    # generate theta values that are tested
    set_theta <- data.frame()
    for(val.cur in seq(0,1,length.out = number_values))
    {
      set_theta <- rbind(set_theta,
                         cbind(rep(val.cur,number_values),
                               seq(0,1,length.out = number_values)))
    }
    set_theta <- set_theta[rowSums(set_theta) <= 1,]
  } else {
    #some tests
    if(!is.data.frame(set_theta))
      set_theta <- as.data.frame(set_theta)

    if(ncol(set_theta)!=2)
      stop("set_theta should have exactly two columns.")

    if(nrow(set_theta)==0)
      stop("set_theta is empty.")

    if(sum(rowSums(set_theta)>1 | rowSums(set_theta)<0)>0)
      stop("sum of first two theta values is not in [0,1]")

  }

  if(is.null(instruments))
    instruments <- "const"

  # safe original data (x,y changed in loop later)
  Xorg <- x
  Yorg <- y

  ### test
  out <- NULL

  if(is.null(vcov_inside))
    vcov_inside <- vcov



  for (inst.cur in instruments) {

      # Specify instruments
      if (is.null(inst.cur)) {
        inst = matrix(1,nrow=n,ncol=1)
      } else if(is.character(inst.cur))
      {
        dat_all <- create.instrument.matrix(Xorg,Yorg,inst.cur,other_data = data)

        inst <- dat_all$w
        y <- dat_all$y
        x <- dat_all$x
      }



        #if bw not given as value, compute with function
        if(!is.numeric(bw))
        {
          bw_fun <- get(bw)
          bw.val <- bw_fun(x,y)
        } else {
          bw_fun <- bw_rule
          bw.val <- bw_fun(x,y)*bw.cur
        }

        for(i.cur in 1:nrow(set_theta))
        {

          theta.cur <- set_theta[i.cur,]

          #compute iden fct values
          res <- id_convex(x,y,
                            theta.cur,
                            bw=bw.val,
                            id_mode = id_mode,
                            vcov=vcov_inside)*inst

          #compute average of identification fct
          mean_id <- colMeans(res)

          #compute sample size
          n <- length(y)

          #compute dof
          J_DoF <- dim(inst)[2]


          # safe covariance info
          var_info <- tryCatch(vcov(res), error=error.var)

          # safe covariance estimation result
          var_id <- if(is.matrix(var_info$cov)) var_info$cov else diag(1,nrow = dim(inst.cur)[2])

          #compute pvalue
          J <- tryCatch(n * mean_id %*% solve(var_id) %*% mean_id, error=function(e) NA)
          pval <- tryCatch(1-pchisq(J,J_DoF), error=function(e) NA)

          out <- rbind(out,
                          c(as.numeric(theta.cur),
                            as.numeric(pval),
                            paste(inst.cur,collapse  = ", ")))

        }

  }

  #assign names
  colnames(out) <- c("theta1", "theta2","pval","instruments")
  out <- as.data.frame(out)


  out$pval <- as.numeric(as.character(out$pval))
  out$theta1 <- as.numeric(as.character(out$theta1))
  out$theta2 <- as.numeric(as.character(out$theta2))

  out <- list(data = out)

  class(out) <- "convex3"

  return(out)
}

#' @export
plot.convex3 <- function(x, alpha_level=c(0.05,0.1))
{
  require(ggplot2)
  require("ggrepel")
  require(latex2exp)


  x$data$label <- NA
  x$data$label[x$data$theta1==0 & x$data$theta2==0]<-"mean"
  x$data$label[x$data$theta1==1 & x$data$theta2==0]<-"median"
  x$data$label[x$data$theta1==0 & x$data$theta2==1]<-"mode"


  # rotate
  x$data$theta1n <- x$data$theta1 + 1/2 * x$data$theta2
  x$data$theta2n <-  sqrt(3)/2 * x$data$theta2
  x$data$theta1 <- x$data$theta1n
  x$data$theta2 <- x$data$theta2n


  if(length(alpha_level)==1)
  {
      plot <- ggplot(x$data,aes(x=theta1,y=theta2, color= factor(pval>alpha_level,levels = c("TRUE","FALSE"))
                                ,size=pval))+
        geom_point()

      plot <- plot +
        theme(
              text = element_text(size=16),
              legend.position="bottom",
              axis.text.x=element_blank(),
              axis.ticks=element_blank(),
              axis.title.x=element_blank(),
              strip.text.y = element_blank(),
              strip.background.y = element_blank(),
              panel.background=element_blank(),
              panel.border=element_blank(),
              panel.grid.major=element_blank(),
              panel.grid.minor=element_blank(),
              plot.background=element_blank())+
        labs(size = "p-value")+
        scale_x_continuous(breaks=c(),labels = c(), name = "", limits = c(-.15,1.15))+
        scale_y_continuous(breaks=c(),labels = c(),name = "", limits = c(-.1,.95))+
        annotate("text", x=.5, y=.95, label="mode", color="black")+
        annotate("text", x=0, y=-.1, label="mean", color="black")+
        annotate("text", x=1, y=-.1, label="median", color="black")

      if(flexible.size){
        plot <- plot +
          scale_size_continuous(limits=c(0,1),range = c(0,4)) + guides(colour = guide_legend(override.aes = list(size=4)), size=F)
      } else{
        plot <- plot +
          scale_size_continuous(limits=c(0,1),range = c(4,4)) + guides(colour = guide_legend(override.aes = list(size=4)), size=F)
      }

    name_legend <- paste0(100-alpha_level*100, "% confidence sets")


    if(color)
      plot <- plot + scale_color_manual(values=c("TRUE"="blue","FALSE"="red"), name=name_legend)
    else
      plot <- plot + scale_color_manual(values=c("TRUE"="black","FALSE"="darkgrey"), name=name_legend)
  } else {

    plot <- ggplot(x$data,aes(x=theta1,y=theta2,
                              color= factor(findInterval(pval,alpha_level),levels=length(alpha_level):0)
                              ,size= pval
    ))+
      geom_point()

    plot <- plot +
      theme(
        text = element_text(size=16),
        legend.position="bottom",
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank())+
      labs(size = "p-value")+
      scale_x_continuous(breaks=c(),labels = c(), name = "", limits = c(-.15,1.15))+
      scale_y_continuous(breaks=c(),labels = c(),name = "", limits = c(-.1,.95))+
      annotate("text", x=.5, y=.95, label="mode", color="black")+
      annotate("text", x=0, y=-.1, label="mean", color="black")+
      annotate("text", x=1, y=-.1, label="median", color="black")

    if(is.null(x$data$yname))
    {
      plot <- plot + theme(
        strip.text.y = element_blank(),
        strip.background.y = element_blank()
      )
    }


    plot <- plot +
      scale_size_continuous(limits=c(0,1),range = c(4,4)) +
      guides(colour = guide_legend(override.aes = list(size=4)), size=F)

    name.legend <- "confidence sets"

    levels.cur <- c(alpha_level)

    levels_label <- NULL
    for(i in 1:length(levels.cur)){
      levels_label <- c(paste0(100-100*levels.cur[i],"%"),levels_label)
    }
    levels_label <- c(levels_label,"rejected")

    plot <- plot + scale_color_grey(start = 0,end = .85,name=name.legend, labels=levels_label,drop = FALSE)
  }

    return( plot <- plot + facet_grid(1~instruments))
}



#' @export
plot_numbers <- function(x, alpha_level=0.1, ...)
{
  require(ggplot2)
  require("ggrepel")
  require(latex2exp)


  #if instruments have instruments format (are not some other variable)
  if(sum(x$data$instruments=="1" | x$data$instruments=="1,x")){
    x$data$instruments = paste0("(", x$data$instruments, ")")
  }


  x$data$label <- NA
  x$data$label[x$data$theta1==0 & x$data$theta2==0]<-"mean"
  x$data$label[x$data$theta1==1 & x$data$theta2==0]<-"median"
  x$data$label[x$data$theta1==0 & x$data$theta2==1]<-"mode"


  # rotate
  x$data$theta1n <- x$data$theta1 + 1/2 * x$data$theta2
  x$data$theta2n <-  sqrt(3)/2 * x$data$theta2
  x$data$theta1 <- x$data$theta1n
  x$data$theta2 <- x$data$theta2n

  x$data$pval_label <- substr(as.character(round(x$data$pval, digits = 2)),2,5)
  x$data$pval_label <- ifelse(substr(x$data$pval_label,1,1)==".",
                              x$data$pval_label,".00")


    plot <- ggplot(x$data,aes(x=theta1,y=theta2,
                              color = factor(pval>alpha_level,levels = c("TRUE","FALSE")),
                              fill = pval,
                              label = pval_label
    ))+
      geom_label()


    plot <- plot +
      theme(
        text = element_text(),
        legend.position="bottom",
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank())+
      labs(size = "p-value")+
      scale_x_continuous(breaks=c(),labels = c(), name = "", limits = c(-.15,1.15))+
      scale_y_continuous(breaks=c(),labels = c(),name = "", limits = c(-.1,.95))+
      annotate("text", x=.5, y=.95, label="mode", color="black")+
      annotate("text", x=0, y=-.1, label="mean", color="black")+
      annotate("text", x=1, y=-.1, label="median", color="black")

    if(is.null(x$data$yname))
    {
      plot <- plot + theme(
        strip.text.y = element_blank(),
        strip.background.y = element_blank()
      )
    }



      plot <- plot +
        scale_size_continuous(limits=c(0,1),range = c(4,4)) + guides(size=F,color=F)

    name_legend <- paste0(100-alpha_level*100, "% confidence sets")

    levels.cur <- c(alpha_level)

    levels_label <- NULL
    for(i in 1:length(levels.cur)){
      levels_label <- c(paste0(100-100*levels.cur[i],"%"),levels_label)
    }
    levels_label <- c(levels_label,"rejected")

     plot <- plot +
       scale_color_manual(values=c("TRUE"="black","FALSE"="white"), name=name_legend)+
       scale_fill_gradient(low="black",high="white",limits=c(0,.2),na.value = "white")+
       facet_grid(1~instruments)

     return(plot)
}




extract_col <- function(data, names)
{
  #find forecast
  cols <- colnames(data) %in% names
  if(sum(cols)>1)
    stop("More than one column detected")
  if(sum(cols)==0)
    stop("No column detected")

  return(data[,cols])
}
